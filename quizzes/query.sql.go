// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package quiz

import (
	"context"
	"database/sql"
	"time"
)

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO questions (quiz_id, question_text, option_a, option_b, option_c, option_d, correct_option)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, quiz_id, question_text, option_a, option_b, option_c, option_d, correct_option, created_at
`

type CreateQuestionParams struct {
	QuizID        int32  `json:"quiz_id"`
	QuestionText  string `json:"question_text"`
	OptionA       string `json:"option_a"`
	OptionB       string `json:"option_b"`
	OptionC       string `json:"option_c"`
	OptionD       string `json:"option_d"`
	CorrectOption string `json:"correct_option"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.queryRow(ctx, q.createQuestionStmt, createQuestion,
		arg.QuizID,
		arg.QuestionText,
		arg.OptionA,
		arg.OptionB,
		arg.OptionC,
		arg.OptionD,
		arg.CorrectOption,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.QuestionText,
		&i.OptionA,
		&i.OptionB,
		&i.OptionC,
		&i.OptionD,
		&i.CorrectOption,
		&i.CreatedAt,
	)
	return i, err
}

const createQuiz = `-- name: CreateQuiz :one
INSERT INTO quizzes (title, description)
VALUES ($1, $2)
RETURNING id, title, description, created_at
`

type CreateQuizParams struct {
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
}

// query.sql
func (q *Queries) CreateQuiz(ctx context.Context, arg CreateQuizParams) (Quiz, error) {
	row := q.queryRow(ctx, q.createQuizStmt, createQuiz, arg.Title, arg.Description)
	var i Quiz
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getQuiz = `-- name: GetQuiz :one
SELECT id, title, description, created_at FROM quizzes
WHERE id = $1
`

func (q *Queries) GetQuiz(ctx context.Context, id int32) (Quiz, error) {
	row := q.queryRow(ctx, q.getQuizStmt, getQuiz, id)
	var i Quiz
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getQuizWithQuestions = `-- name: GetQuizWithQuestions :many
SELECT q.id, q.title, q.description, q.created_at, qs.id as question_id, qs.question_text, 
       qs.option_a, qs.option_b, qs.option_c, qs.option_d, qs.correct_option
FROM quizzes q
JOIN questions qs ON q.id = qs.quiz_id
WHERE q.id = $1
`

type GetQuizWithQuestionsRow struct {
	ID            int32          `json:"id"`
	Title         string         `json:"title"`
	Description   sql.NullString `json:"description"`
	CreatedAt     time.Time      `json:"created_at"`
	QuestionID    int32          `json:"question_id"`
	QuestionText  string         `json:"question_text"`
	OptionA       string         `json:"option_a"`
	OptionB       string         `json:"option_b"`
	OptionC       string         `json:"option_c"`
	OptionD       string         `json:"option_d"`
	CorrectOption string         `json:"correct_option"`
}

func (q *Queries) GetQuizWithQuestions(ctx context.Context, id int32) ([]GetQuizWithQuestionsRow, error) {
	rows, err := q.query(ctx, q.getQuizWithQuestionsStmt, getQuizWithQuestions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuizWithQuestionsRow
	for rows.Next() {
		var i GetQuizWithQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
			&i.QuestionID,
			&i.QuestionText,
			&i.OptionA,
			&i.OptionB,
			&i.OptionC,
			&i.OptionD,
			&i.CorrectOption,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuizzes = `-- name: ListQuizzes :many
SELECT id, title, description, created_at FROM quizzes
ORDER BY created_at DESC
`

func (q *Queries) ListQuizzes(ctx context.Context) ([]Quiz, error) {
	rows, err := q.query(ctx, q.listQuizzesStmt, listQuizzes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Quiz
	for rows.Next() {
		var i Quiz
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE questions
SET question_text = COALESCE($1, question_text),
    option_a = COALESCE($2, option_a),
    option_b = COALESCE($3, option_b),
    option_c = COALESCE($4, option_c),
    option_d = COALESCE($5, option_d),
    correct_option = COALESCE($6, correct_option)
WHERE id = $7
RETURNING id, quiz_id, question_text, option_a, option_b, option_c, option_d, correct_option, created_at
`

type UpdateQuestionParams struct {
	QuestionText  string `json:"question_text"`
	OptionA       string `json:"option_a"`
	OptionB       string `json:"option_b"`
	OptionC       string `json:"option_c"`
	OptionD       string `json:"option_d"`
	CorrectOption string `json:"correct_option"`
	ID            int32  `json:"id"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (Question, error) {
	row := q.queryRow(ctx, q.updateQuestionStmt, updateQuestion,
		arg.QuestionText,
		arg.OptionA,
		arg.OptionB,
		arg.OptionC,
		arg.OptionD,
		arg.CorrectOption,
		arg.ID,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.QuestionText,
		&i.OptionA,
		&i.OptionB,
		&i.OptionC,
		&i.OptionD,
		&i.CorrectOption,
		&i.CreatedAt,
	)
	return i, err
}
